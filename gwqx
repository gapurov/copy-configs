#!/usr/bin/env bash
# gwqx — Enhanced gwq with post-create file copying
# Version: 2.2.0
#
# SUMMARY
#   Multi-purpose gwq enhancement tool:
#   1. Acts as gwq wrapper when called as 'gwq', delegating to real gwq
#   2. Provides 'addx' subcommand for worktree creation with file copying
#   3. Can be called directly as 'gwqx' for the addx functionality
#
# REQUIREMENTS
#   - bash 3.2+
#   - git, gwq, jq (for detecting new worktrees)
#   - copy-configs.sh (standalone copy utility)
#
# USAGE
#   gwq addx [OPTIONS] [--] [gwq add args...]
#   gwqx [OPTIONS] [--] [gwq add args...]


set -euo pipefail


# ---------- constants ----------
readonly SCRIPT_VERSION="2.2.0"
readonly REQUIRED_DEPS=(git jq)
readonly COPY_CONFIGS_SCRIPT="$(dirname "$0")/copy-configs.sh"

# ---------- global variables ----------
use_color=1
is_tty=0
verbose_mode=0
debug_mode=0
dry_run_mode=0
GWQ_ARGS=()
COPY_ARGS=()

# ---------- initialization ----------
[[ -t 1 ]] && is_tty=1

# ---------- logging ----------
log() {
    local level="$1"; shift
    local prefix icon color output_fd=1

    case "$level" in
        info)  prefix='>>' icon='>>'; color='36'; output_fd=2 ;;
        ok)    prefix='✓'  icon='✓';  color='32'; output_fd=2 ;;
        warn)  prefix='--' icon='--'; color='90'; output_fd=2 ;;
        error) prefix='!!' icon='!!'; color='31'; output_fd=2 ;;
        verb)  [[ $verbose_mode -eq 1 ]] || return 0; prefix='**' icon='**'; color='35'; output_fd=2 ;;
        debug) [[ $debug_mode -eq 1 ]] || return 0; prefix='DD' icon='DD'; color='33'; output_fd=2 ;;
        dry)   [[ $dry_run_mode -eq 1 ]] || return 0; prefix='DRY' icon='DRY'; color='96'; output_fd=2 ;;
        *) log error "Unknown log level: $level"; return 1 ;;
    esac

    if [[ $use_color -eq 1 && $is_tty -eq 1 ]]; then
        printf "\033[${color}m${icon}\033[0m %s\n" "$*" >&$output_fd
    else
        printf "%s %s\n" "$prefix" "$*" >&$output_fd
    fi
}

# ---------- gwq resolution ----------
find_real_gwq() {
    if [[ -n "${GWQX_REAL_GWQ:-}" ]]; then
        printf '%s\n' "$GWQX_REAL_GWQ"
        return 0
    fi

    if command -v -p gwq >/dev/null 2>&1; then
        command -v -p gwq
        return 0
    fi

    local script_dir
    if script_dir=$(cd "$(dirname "${BASH_SOURCE[0]:-}")" 2>/dev/null && pwd -P); then
        :
    else
        script_dir=""
    fi

    local path_entry
    local path_entries=()
    IFS=':' read -r -a path_entries <<<"${PATH:-}"
    for path_entry in "${path_entries[@]}"; do
        if [[ -z "$path_entry" ]]; then
            continue
        fi
        local candidate="$path_entry/gwq"
        if [[ -x "$candidate" ]]; then
            if [[ -n "$script_dir" && "$candidate" == "$script_dir/gwqx" ]]; then
                continue
            fi
            printf '%s\n' "$candidate"
            return 0
        fi
    done

    log error "gwq command not found in PATH. Please install gwq first."
    exit 1
}

readonly REAL_GWQ="$(find_real_gwq)"

# ---------- dependency management ----------
check_dependencies() {
    local missing=()
    local dep

    for dep in "${REQUIRED_DEPS[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing+=("$dep")
        fi
    done

    if [[ ${#missing[@]} -gt 0 ]]; then
        log error "Missing required commands: ${missing[*]}"
        exit 1
    fi

    if [[ ! -x "$REAL_GWQ" ]]; then
        log error "Real gwq executable not found or not executable: $REAL_GWQ"
        exit 1
    fi

    # Check for copy-configs.sh
    if [[ ! -x "$COPY_CONFIGS_SCRIPT" ]]; then
        log error "copy-configs.sh not found or not executable: $COPY_CONFIGS_SCRIPT"
        log error "Please ensure copy-configs.sh is in the same directory as this script"
        exit 1
    fi

    log debug "All dependencies verified: ${REQUIRED_DEPS[*]}, gwq -> $REAL_GWQ, copy-configs.sh"
}

# ---------- help ----------
print_help() {
    cat <<'EOF'
Usage: gwq addx [OPTIONS] [--] [gwq add args...]
   or: gwqx [OPTIONS] [--] [gwq add args...]

Creates git worktrees using 'gwq add' and then copies configuration files
into the new worktree directories using copy-configs.sh.

Copy-related OPTIONS (passed to copy-configs.sh):
  --config, -c FILE     Path to rules file (overrides default search)
  --conflict, -C MODE   skip|overwrite|backup   (default: skip)
  --no-color            Disable ANSI colors in output
  --verbose, -v         Enable verbose output
  --debug               Enable debug output
  --dry-run, -n         Show what would be done without executing
  --help, -h            Show help

All other arguments are passed to 'gwq add'.

EXAMPLES:
  # Create worktree with new branch and copy files
  gwq addx -b feature/auth

  # Create from existing branch
  gwq addx main

  # With copy configuration
  gwq addx --config ./custom.copyconfigs -b feature/api

  # Dry run to see what would be copied
  gwq addx --dry-run -b feature/test

NOTES:
  - Uses copy-configs.sh for file copying (must be in same directory)
  - Default copies: .env*, CLAUDE.md, .cursor/, .vscode/settings.json
  - Config file: .copyconfigs (repo) or ~/.config/copy-configs/config (global)
  - Legacy config files are still supported
EOF
}

# ---------- argument parsing ----------
parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case "${1:-}" in
            -h|--help)
                print_help; exit 0 ;;
            # Copy-related arguments
            -c|--config|--conflict|-C|--copy-on-conflict)
                COPY_ARGS+=("$1")
                if [[ $# -ge 2 ]]; then
                    COPY_ARGS+=("$2")
                    shift 2
                else
                    log error "Missing argument for $1"
                    exit 1
                fi
                continue ;;
            --no-color)
                use_color=0
                COPY_ARGS+=("$1")
                shift; continue ;;
            -v|--verbose)
                verbose_mode=1
                COPY_ARGS+=("$1")
                shift; continue ;;
            --debug)
                debug_mode=1; verbose_mode=1
                COPY_ARGS+=("$1")
                shift; continue ;;
            -n|--dry-run)
                dry_run_mode=1; verbose_mode=1
                COPY_ARGS+=("$1")
                shift; continue ;;
            --)
                shift
                while [[ $# -gt 0 ]]; do
                    GWQ_ARGS+=("$1"); shift
                done
                break ;;
            *)
                # All other arguments go to gwq add
                GWQ_ARGS+=("$1"); shift ;;
        esac
    done
}

run_addx() {
    check_dependencies

    GWQ_ARGS=()
    COPY_ARGS=()

    parse_arguments "$@"

    log debug "Parsed arguments: verbose=$verbose_mode debug=$debug_mode dry_run=$dry_run_mode"
    log debug "GWQ args: ${GWQ_ARGS[*]:-<none>}"
    log debug "Copy args: ${COPY_ARGS[*]:-<none>}"

    if [[ ${#GWQ_ARGS[@]} -eq 0 ]]; then
        log error "No arguments provided to gwq add"
        print_help
        exit 1
    fi

    # ---------- worktree detection ----------
    local new_paths=""
    if ! new_paths="$(get_new_worktrees)"; then
        log error "Failed to determine new worktree paths"
        exit 1
    fi

    log debug "New worktree paths: '$new_paths'"

    if [[ -z $new_paths ]]; then
        log warn "No new worktree paths detected. Nothing to copy."
        exit 0
    fi

    local path_count
    path_count=$(printf '%s\n' "$new_paths" | sed '/^$/d' | wc -l | tr -d ' ')

    log info "Copying files into $path_count new worktree(s)"

    if printf '%s\n' "$new_paths" | "$COPY_CONFIGS_SCRIPT" "${COPY_ARGS[@]}"; then
        log ok "Done."
    else
        log error "File copying failed"
        exit 1
    fi
}

get_worktree_paths() {
    local json_output
    if json_output=$("$REAL_GWQ" list --json 2>/dev/null); then
        echo "$json_output" | jq -r '.[].path' 2>/dev/null | LC_ALL=C sort -u
    else
        log warn "Failed to get worktree paths from gwq list --json"
        return 1
    fi
}

get_new_worktrees() {
    # Snapshot before
    local before_file after_file
    before_file="$(mktemp)" || { log error "mktemp failed"; return 1; }
    after_file="$(mktemp)" || { log error "mktemp failed"; rm -f "$before_file"; return 1; }

    if ! get_worktree_paths >"$before_file"; then
        log error "Failed to get initial worktree list"
        rm -f "$before_file" "$after_file"
        exit 1
    fi

    # Run gwq add
    log info "Creating worktree(s): gwq add ${GWQ_ARGS[*]}"
    if [[ $dry_run_mode -eq 1 ]]; then
        log dry "Would run: gwq add ${GWQ_ARGS[*]}"
        printf '/tmp/dry-run-worktree-1\n'
        rm -f "$before_file" "$after_file"
        return 0
    else
        local gwq_output
        if gwq_output="$(GWQX_WRAPPED=1 "$REAL_GWQ" add "${GWQ_ARGS[@]}" 2>&1)"; then
            log verb "gwq add output: $gwq_output"
        else
            log error "gwq add failed: $gwq_output"
            rm -f "$before_file" "$after_file"
            exit 1
        fi
    fi

    # Snapshot after
    if ! get_worktree_paths >"$after_file"; then
        log error "Failed to get updated worktree list"
        rm -f "$before_file" "$after_file"
        exit 1
    fi

    # Print lines present only in after (new worktrees)
    if command -v comm >/dev/null 2>&1; then
        comm -13 "$before_file" "$after_file" || true
    else
        # Fallback without comm
        grep -vxFf "$before_file" "$after_file" || true
    fi

    rm -f "$before_file" "$after_file"
}

main() {
    if [[ ${1:-} != "addx" ]]; then
        exec "$REAL_GWQ" "$@"
    fi

    shift
    run_addx "$@"
}

main "$@"
